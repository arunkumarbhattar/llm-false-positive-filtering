#!/usr/bin/env python3
"""
add_ground_truth.py

This script processes a CodeQL-generated SARIF file, labels each finding
with ground truth information (True Positive, False Positive, or Not Applicable),
and outputs a labeled SARIF file.

Usage:
    python add_ground_truth.py --sarif-input cpp.sarif --tags-file tags.txt --sarif-output cpp-labeled.sarif
"""

import json
import re
import argparse
import os
from enum import Enum
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

class GroundTruth(Enum):
    GOOD = "FP"       # False Positive
    BAD = "TP"        # True Positive
    UNRELATED = "N/A" # Not Applicable

def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        argparse.Namespace: Parsed command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Label CodeQL SARIF results with ground truth information.")
    parser.add_argument('--sarif-input', required=True, help="Path to the input CodeQL SARIF file.")
    parser.add_argument('--tags-file', required=True, help="Path to the tags file generated by ctags.")
    parser.add_argument('--sarif-output', required=True, help="Path to the output labeled SARIF file.")
    return parser.parse_args()

def full_path(base_dir, rel_path):
    """
    Constructs the absolute path by joining the base directory with a relative path.

    Args:
        base_dir (str): The base directory path.
        rel_path (str): The relative path.

    Returns:
        str: The combined absolute path.
    """
    return os.path.join(base_dir, rel_path)

def parse_tagfile(tags_path):
    """
    Parses the tags file to map filenames to their functions and corresponding line ranges.

    Args:
        tags_path (str): Path to the tags file.

    Returns:
        dict: A dictionary mapping filenames to lists of (function_name, start_line, end_line).
    """
    tags = {}
    try:
        with open(tags_path, 'r') as file:
            for line in file:
                line = line.strip()
                if not line or line.startswith('!'):
                    continue  # Skip empty lines and metadata

                parts = line.split('\t')
                if len(parts) < 3:
                    logging.warning(f"Malformed tags line: {line}")
                    continue

                funcname, filename, details = parts[:3]

                # Extract start and end lines using regex
                start_match = re.search(r'line:(\d+)', details)
                end_match = re.search(r'end:(\d+)', details)

                if start_match:
                    startline = int(start_match.group(1))
                else:
                    logging.warning(f"Start line not found in line: {line}")
                    startline = 0

                if end_match:
                    endline = int(end_match.group(1))
                else:
                    # If end line isn't provided, assume function is a single line
                    endline = startline

                tags.setdefault(filename, []).append((funcname, startline, endline))
    except FileNotFoundError:
        logging.error(f"Tags file not found: {tags_path}")
    except Exception as e:
        logging.error(f"Error parsing tags file: {e}")
    return tags

def get_function_loc(tags, src_filename, lineno):
    """
    Determines which function a specific line number belongs to within a source file.

    Args:
        tags (dict): Parsed tags mapping filenames to functions.
        src_filename (str): The source file name.
        lineno (int): The line number to locate.

    Returns:
        tuple or None: (function_name, start_line, end_line) if found, else None.
    """
    functions = tags.get(src_filename, [])
    matched_funcs = [func for func in functions if func[1] <= lineno <= func[2]]

    if len(matched_funcs) == 1:
        return matched_funcs[0]
    elif len(matched_funcs) > 1:
        logging.warning(f"Multiple functions match {src_filename}:{lineno}: {matched_funcs}")
    else:
        logging.warning(f"No matching function found for {src_filename}:{lineno}")
    return None

def is_good(string):
    """
    Checks if the given string indicates a 'good' (non-vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'good' is in the string, else False.
    """
    return bool(string) and re.search(r'\bgood\b', string, re.IGNORECASE)

def is_bad(string):
    """
    Checks if the given string indicates a 'bad' (vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'bad' is in the string, else False.
    """
    return bool(string) and re.search(r'\bbad\b', string, re.IGNORECASE)

def get_codeql_result_ground_truth(result, rules_metadata, tags, base_dir):
    """
    Determines the ground truth label for a given CodeQL result.

    Args:
        result (dict): A single result from the SARIF file.
        rules_metadata (list): Metadata about the rules from the SARIF runs.
        tags (dict): Parsed tags mapping filenames to functions.
        base_dir (str): The base directory path.

    Returns:
        str: Ground truth label ("TP", "FP", or "N/A").
    """
    rule_id = result.get('ruleId')
    rule_index = result.get('ruleIndex')

    if rule_id == 'cpp/missing-header-guard':
        return GroundTruth.UNRELATED.value  # "N/A"

    # Extract CWE numbers associated with the rule
    rule_tags = rules_metadata[rule_index].get("properties", {}).get("tags", [])
    rule_cwe_numbers = set()
    for tag in rule_tags:
        cwe_matches = re.findall(r'\bcwe-(\d+)\b', tag, re.IGNORECASE)
        rule_cwe_numbers.update(int(num) for num in cwe_matches)

    # Additional CWE numbers for specific rules
    additional_cwe = {
        'cpp/bad-strncpy-size': [121, 122],
        'cpp/unsafe-strcat': [121, 122],
        'cpp/badly-bounded-write': [121, 122],
        'cpp/static-buffer-overflow': [121, 122],
        'cpp/very-likely-overrunning-write': [121, 122],
        'cpp/suspicious-sizeof': [121, 122],
        'cpp/unbounded-write': [242],
    }
    if rule_id in additional_cwe:
        rule_cwe_numbers.update(additional_cwe[rule_id])

    for location in result.get('locations', []):
        phys_loc = location.get('physicalLocation', {})
        artifact = phys_loc.get('artifactLocation', {})
        uri = artifact.get('uri')
        lineno = phys_loc.get('region', {}).get('startLine')

        if not uri or not lineno:
            logging.warning(f"Missing URI or line number in result: {result}")
            continue

        # Extract CWE numbers from the URI
        cwe_matches = re.findall(r'CWE(\d+)', uri, re.IGNORECASE)
        uri_cwe_numbers = set(int(num) for num in cwe_matches)

        # Check if there's an intersection between rule CWE numbers and URI CWE numbers
        if not uri_cwe_numbers.intersection(rule_cwe_numbers):
            return GroundTruth.UNRELATED.value  # "N/A"

        # Determine the function containing the issue
        func_loc = get_function_loc(tags, uri, lineno)
        if not func_loc:
            logging.warning(f"Cannot determine function for {uri}:{lineno}")
            return GroundTruth.UNRELATED.value  # "N/A"

        func_name, _, _ = func_loc
        src_code = get_src_code(uri, lineno)

        # Determine ground truth based on 'good' or 'bad' in filename, function name, or source code
        if is_good(uri) or is_good(func_name) or is_good(src_code):
            return GroundTruth.GOOD.value  # "FP"
        if is_bad(uri) or is_bad(func_name) or is_bad(src_code):
            return GroundTruth.BAD.value   # "TP"

        logging.warning(f"Ground truth ambiguous for {rule_id}@{uri}:{lineno}")
    return GroundTruth.UNRELATED.value  # "N/A"

def get_src_code(uri, lineno, base_dir):
    """
    Retrieves the source code line at a specific line number from a file.

    Args:
        uri (str): Relative path to the source file.
        lineno (int): The line number to retrieve.
        base_dir (str): The base directory path.

    Returns:
        str: The source code line or an error message.
    """
    path = full_path(base_dir, uri)
    try:
        with open(path, 'r') as file:
            lines = file.readlines()
            return lines[lineno - 1].strip()  # 1-based indexing
    except FileNotFoundError:
        logging.error(f"Source file not found: {path}")
        return ""
    except IndexError:
        logging.error(f"Line number {lineno} out of range in file: {path}")
        return ""

def add_ground_truth_to_sarif(sarif_input, tags_file, sarif_output, base_dir):
    """
    Processes the SARIF file, labels each finding with ground truth, and writes the labeled SARIF.

    Args:
        sarif_input (str): Path to the input SARIF file.
        tags_file (str): Path to the tags file.
        sarif_output (str): Path to the output labeled SARIF file.
        base_dir (str): The base directory path.
    """
    # Parse the tags file
    tags = parse_tagfile(tags_file)
    logging.info(f"Parsed tags from {tags_file}")

    # Load the SARIF file
    try:
        with open(sarif_input, 'r') as f:
            sarif_data = json.load(f)
        logging.info(f"Loaded SARIF file: {sarif_input}")
    except FileNotFoundError:
        logging.error(f"SARIF file not found: {sarif_input}")
        return
    except json.JSONDecodeError as e:
        logging.error(f"Error parsing SARIF file: {e}")
        return

    # Process each run in the SARIF file
    for run in sarif_data.get('runs', []):
        rules_metadata = run.get('tool', {}).get('driver', {}).get('rules', [])
        if not rules_metadata:
            logging.warning("No rules metadata found in SARIF run.")

        for result in run.get('results', []):
            gt = get_codeql_result_ground_truth(result, rules_metadata, tags, base_dir)
            result.setdefault('properties', {})['groundTruth'] = gt
            logging.debug(f"Labeled result with ground truth: {gt}")

    # Write the labeled SARIF data to the output file
    try:
        with open(sarif_output, 'w') as f:
            json.dump(sarif_data, f, indent=2)
        logging.info(f"Labeled SARIF written to {sarif_output}")
    except Exception as e:
        logging.error(f"Error writing labeled SARIF file: {e}")

def main():
    args = parse_arguments()
    base_dir = os.path.dirname(os.path.abspath(args.sarif_input))

    add_ground_truth_to_sarif(
        sarif_input=args.sarif_input,
        tags_file=args.tags_file,
        sarif_output=args.sarif_output,
        base_dir=base_dir
    )

if __name__ == '__main__':
    main()
