#!/usr/bin/env python3
"""
add_ground_truth.py

This script processes a CodeQL-generated SARIF file, labels each finding
with ground truth information (True Positive, False Positive, or Not Applicable),
and outputs a labeled SARIF file.

Usage:
    python add_ground_truth.py --base-dir /path/to/juliet-test-suite --sarif-input cpp.sarif --tags-file tags.txt --sarif-output cpp-labeled-20241106.sarif
"""

import json
import re
from enum import Enum
import os
import argparse
import logging

# Configure logging to display informational and error messages
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


class GroundTruth(Enum):
    """
    Enumeration representing the ground truth labels for CodeQL alerts.

    Members:
        GOOD (str): Indicates a False Positive (FP).
        BAD (str): Indicates a True Positive (TP).
        UNRELATED (str): Indicates Not Applicable (N/A).
        ERR (str): Indicates an error in processing.
    """
    GOOD = "FP"       # False Positive
    BAD = "TP"        # True Positive
    UNRELATED = "N/A" # Not Applicable
    ERR = "ERR"       # Error


def parse_arguments():
    """
    Parses command-line arguments provided by the user.

    Returns:
        argparse.Namespace: An object containing parsed command-line arguments.

    The script expects the following arguments:
        --base-dir    : Base directory of the Juliet test suite repository.
        --sarif-input : Path to the input CodeQL SARIF file.
        --tags-file   : Path to the tags file generated by ctags.
        --sarif-output: Path where the labeled SARIF file will be saved.
    """
    parser = argparse.ArgumentParser(description="Label CodeQL SARIF results with ground truth information.")
    parser.add_argument('--base_dir', required=True, help="Base directory of the Juliet test suite repository.")
    parser.add_argument('--sarif_input', required=True, help="Path to the input CodeQL SARIF file.")
    parser.add_argument('--tags_file', required=True, help="Path to the tags file generated by ctags.")
    parser.add_argument('--sarif_output', required=True, help="Path to the output labeled SARIF file.")
    return parser.parse_args()


def full_path(base_dir, rel_path):
    """
    Constructs the absolute path by joining the base directory with a relative path.

    Args:
        base_dir (str): The base directory path.
        rel_path (str): The relative path to be joined with the base directory.

    Returns:
        str: The combined absolute path.
    """
    return os.path.join(base_dir, rel_path)


def get_src_code(base_dir, uri, lineno):
    """
    Retrieves the source code line at a specific line number from a file.

    Args:
        base_dir (str): The base directory path.
        uri (str): Relative path to the source file.
        lineno (int): The line number to retrieve.

    Returns:
        str: The source code line or an error message if the file or line number is invalid.
    """
    try:
        with open(full_path(base_dir, uri), 'r') as file:
            lines = file.readlines()
            return lines[lineno - 1].strip()  # lineno is 1-based, so we subtract 1
    except (FileNotFoundError, IndexError) as e:
        return f"Error: {e}"


def get_codeql_result_ground_truth(r, rules_metadata, ctags, base_dir) -> str:
    """
    Determines the ground truth label for a given CodeQL result.

    Args:
        r (dict): A single result entry from the SARIF file.
        rules_metadata (list): Metadata about the rules from the SARIF runs.
        ctags (dict): Parsed tags mapping filenames to functions and their locations.
        base_dir (str): The base directory path for resolving file paths.

    Returns:
        str: Ground truth label ("TP", "FP", or "N/A").

    This function assesses whether a CodeQL alert is a True Positive, False Positive, or Not Applicable
    based on the rule's CWE numbers, the context of the alert in the source code, and the presence
    of 'good' or 'bad' indicators in the filename, function name, or source code.
    """
    ruleId = r['ruleId']
    ruleIndex = r['ruleIndex']
    # Uncomment the following lines if rule level filtering is needed
    # rule_level = rules_metadata[ruleIndex]['defaultConfiguration']['level']
    # if rule_level not in ['error', 'warning']:
    #     return "N/A"

    if ruleId == 'cpp/missing-header-guard':
        return "N/A"

    rule_tags = rules_metadata[ruleIndex]["properties"]["tags"]
    rule_cwe_numbers = set()
    for tag in rule_tags:
        # An example of a tag: "external/cwe/cwe-401"
        cwe_matches = re.findall(r'\bcwe-(\d+)\b', tag, re.IGNORECASE)
        rule_cwe_numbers.update(int(num) for num in cwe_matches)

    # Additional CWE numbers for specific rules not covered by metadata
    if ruleId in [
        'cpp/bad-strncpy-size',
        'cpp/unsafe-strcat',
        'cpp/badly-bounded-write',
        'cpp/static-buffer-overflow',
        'cpp/very-likely-overrunning-write',
        'cpp/suspicious-sizeof'
    ]:
        rule_cwe_numbers.update([121, 122])
    if ruleId in ['cpp/unbounded-write']:
        rule_cwe_numbers.add(242)

    for l in r.get('locations', []):
        # Extract URI and line number from the location object
        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)
        lineno = l.get('physicalLocation', {}).get('region', {}).get('startLine', None)

        if not uri or not lineno:
            logging.warning(f"Missing URI or line number in result: {r}")
            continue

        # Find all distinct CWE numbers in URI (e.g., CWE121)
        cwe_matches = re.findall(r'CWE(\d+)', uri, re.IGNORECASE)
        uri_cwe_numbers = set(int(num) for num in cwe_matches)

        # Determine if there is any overlap between rule CWE numbers and URI CWE numbers
        if not uri_cwe_numbers.intersection(rule_cwe_numbers):
            return "N/A"

        func_loc = get_function_loc(ctags, uri, lineno)
        if not func_loc:
            logging.warning(f"Cannot find the function surrounding {ruleId}@{uri}:{lineno}")
            # Uncomment the following line if you want to return "N/A" when function location is not found
            # return "N/A"

        func_name, _, _ = func_loc
        src_code = get_src_code(base_dir, uri, lineno)

        # Determine ground truth based on presence of 'good' or 'bad' indicators
        if is_good(uri) or is_good(func_name) or is_good(src_code):
            return "FP"
        if is_bad(uri) or is_bad(func_name) or is_bad(src_code):
            return "TP"

        logging.warning(f"Neither good nor bad indicators found for {ruleId}@{uri}:{lineno}")
    return "N/A"


def parse_codeql_sarif(filename, base_dir, sarif_output):
    """
    Parses a CodeQL SARIF file, labels each result with ground truth information,
    and writes the labeled SARIF to the specified output file.

    Args:
        filename (str): Path to the input CodeQL SARIF file.
        base_dir (str): The base directory path for resolving file paths.
        sarif_output (str): Path to the output labeled SARIF file.

    Functionality:
        - Loads the SARIF file.
        - Parses the tags file to map filenames to functions.
        - Iterates through each result in the SARIF file.
        - Determines the ground truth label for each result.
        - Assigns the ground truth label to the result.
        - Writes the updated SARIF data to the output file.
    """
    try:
        with open(full_path(base_dir, filename), 'r') as f:
            s = json.load(f)
        logging.info(f"Successfully loaded SARIF file: {filename}")
    except FileNotFoundError:
        logging.error(f"SARIF file not found: {filename}")
        return
    except json.JSONDecodeError as e:
        logging.error(f"Error decoding JSON from SARIF file: {e}")
        return

    # Parse the tags file to map filenames to functions
    ctags = parse_tagfile(full_path(base_dir, 'tags'))
    logging.info(f"Successfully parsed tags from 'tags' file.")

    for run in s.get('runs', []):
        rules_metadata = run['tool']['driver']['rules']
        for r in run.get('results', []):
            gt = get_codeql_result_ground_truth(r, rules_metadata, ctags, base_dir)
            r['properties'] = r.get('properties', {})
            r['properties']['groundTruth'] = gt
            logging.debug(f"Labeled result: {gt}")

    # Write the labeled SARIF data to the output file
    try:
        with open(full_path(base_dir, sarif_output), 'w') as f:
            json.dump(s, f, indent=2)
        logging.info(f"Successfully wrote labeled SARIF to: {sarif_output}")
    except Exception as e:
        logging.error(f"Error writing labeled SARIF file: {e}")


def parse_tagfile(tagfile):
    """
    Parses the tags file to map filenames to their functions and corresponding line ranges.

    Args:
        tagfile (str): Absolute path to the tags file.

    Returns:
        dict: A dictionary where each key is a filename and the value is a list of tuples:
              (function_name, start_line, end_line).

    The tags file is expected to be in the format generated by ctags, with each line containing
    function information such as name, file path, start line, and end line.
    """
    results = {}
    try:
        with open(tagfile) as file:
            for line in file:
                line = line.rstrip()
                if not line or line[0] == '!':
                    continue  # Skip empty lines and metadata lines starting with '!'

                startline, endline = 0, 0
                m = re.search(r"line:(\d+)", line)
                if m:
                    startline = int(m.group(1))
                m = re.search(r"end:(\d+)", line)
                if m:
                    endline = int(m.group(1))

                parts = line.split('\t')
                if len(parts) < 3:
                    logging.warning(f"Malformed tags line: {line}")
                    continue  # Skip malformed lines

                funcname = parts[0]
                filename = parts[1]

                # Append the function details to the results dictionary
                results.setdefault(filename, []).append(
                    (funcname, startline, endline))
    except FileNotFoundError:
        logging.error(f"Tags file not found: {tagfile}")
    except Exception as e:
        logging.error(f"Error parsing tags file: {e}")
    return results


def is_good(string):
    """
    Checks if the given string indicates a 'good' (non-vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'good' is in the string (case-insensitive), else False.
    """
    if string:
        return 'good' in string.lower()
    return False


def is_bad(string):
    """
    Checks if the given string indicates a 'bad' (vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'bad' is in the string (case-insensitive), else False.
    """
    if string:
        return 'bad' in string.lower()
    return False


def get_function_loc(tags, src_filename, lineno):
    """
    Determines which function a specific line number belongs to within a source file.

    Args:
        tags (dict): Parsed tags mapping filenames to functions and their locations.
        src_filename (str): The source file name.
        lineno (int): The line number within the source file.

    Returns:
        tuple or (None, None, None): A tuple containing (function_name, start_line, end_line) if a unique match is found;
                                      (None, None, None) otherwise.

    Functionality:
        - Retrieves all functions in the specified file.
        - Filters functions that encompass the given line number.
        - Logs warnings if multiple or no matching functions are found.
    """
    value = tags.get(src_filename)
    if value:
        matched_funcs = [
            (func_name, start, end) for func_name, start, end in value
            if start <= lineno <= end]
        if len(matched_funcs) == 1:
            return matched_funcs[0]
        else:
            logging.warning(f"Multiple or no match: {matched_funcs} in file {src_filename} at line {lineno}")
    else:
        logging.warning(f"Source file not found in tags: {src_filename}")

    return None, None, None


def dump_src(base_dir, filename, start, end):
    """
    Given a filename and start and end line numbers, return a string containing
    the file content from the start line to the end line (inclusive), with each
    line prepended by its line number.

    Args:
        base_dir (str): The base directory path.
        filename (str): The name of the file to read from.
        start (int): The starting line number (1-based).
        end (int): The ending line number (inclusive, 1-based).

    Returns:
        str: A string containing the file content from start line to end line
             with line numbers prepended.

    Functionality:
        - Opens the specified file and reads its lines.
        - Extracts the lines from start to end.
        - Prepends each line with its corresponding line number.
        - Returns the concatenated string of numbered lines.
    """
    try:
        with open(full_path(base_dir, filename), 'r') as file:
            lines = file.readlines()
    except FileNotFoundError:
        logging.error(f"Source file not found: {full_path(base_dir, filename)}")
        return ""
    except Exception as e:
        logging.error(f"Error reading file {full_path(base_dir, filename)}: {e}")
        return ""

    # Ensure the line numbers are within the valid range
    start = max(1, start)  # Ensure start is at least 1
    end = min(len(lines), end)  # Ensure end does not exceed the number of lines

    # Slice the list to get lines from start to end (inclusive)
    selected_lines = lines[start-1:end]

    # Prepend line numbers
    numbered_lines = [f"{i+start}: {line}" for i, line in enumerate(selected_lines)]

    # Join the selected lines into a single string
    return ''.join(numbered_lines)


def main():
    """
    The main function orchestrates the parsing of CodeQL SARIF files, extraction of function definitions,
    determination of ground truth labels, and writing of the labeled SARIF file.

    Steps:
        1. Parses command-line arguments to obtain base directory, input SARIF file, tags file, and output SARIF file paths.
        2. Parses the tags file to map filenames to functions and their line ranges.
        3. Parses the CodeQL SARIF file, determines ground truth labels for each result, and assigns them.
        4. Writes the updated SARIF data with ground truth labels to the specified output file.
    """
    args = parse_arguments()

    # Assign the base directory from command-line arguments
    base_dir = args.base_dir

    # Validate the base directory
    if not os.path.isdir(base_dir):
        logging.error(f"Base directory does not exist or is not a directory: {base_dir}")
        return

    # Parse the CodeQL SARIF file and add ground truth labels
    parse_codeql_sarif(args.sarif_input, base_dir, args.sarif_output)


if __name__ == '__main__':
    main()
