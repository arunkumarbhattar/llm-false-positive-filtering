#!/usr/bin/env python3
"""
parse.py

This script compares CodeQL-generated SARIF results against ground truth data
from the Juliet Test Suite's manifest.xml. It categorizes each finding as
a True Positive (TP), False Positive (FP), or Unrelated based on function
and file naming conventions.

Usage:
    python parse.py --sarif cpp.sarif --tags tags.txt --manifest C/manifest.xml
"""

import argparse
import json
import logging
import os
import re
import sys
import xml.etree.ElementTree as ET
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


class GroundTruth(Enum):
    TP = "True Positive"
    FP = "False Positive"
    UNRELATED = "Unrelated"


def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        argparse.Namespace: Parsed command-line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Compare CodeQL SARIF results against Juliet Test Suite ground truth."
    )
    parser.add_argument(
        '--sarif',
        required=True,
        help="Path to the CodeQL-generated SARIF file (e.g., cpp.sarif)."
    )
    parser.add_argument(
        '--tags',
        required=True,
        help="Path to the tags file generated by ctags (e.g., tags.txt)."
    )
    parser.add_argument(
        '--manifest',
        required=True,
        help="Path to the Juliet Test Suite's manifest XML file (e.g., C/manifest.xml)."
    )
    return parser.parse_args()


def full_path(base_dir, rel_path):
    """
    Constructs the absolute path by joining the base directory with a relative path.

    Args:
        base_dir (str): The base directory path.
        rel_path (str): The relative path.

    Returns:
        str: The combined absolute path.
    """
    return os.path.join(base_dir, rel_path)


def parse_manifest_xml(filename):
    """
    Parses the manifest XML to extract ground truth vulnerabilities.

    Args:
        filename (str): Path to the manifest XML file.

    Returns:
        set: A set of tuples containing (file_path, line_number).
    """
    ground_truth = set()
    try:
        tree = ET.parse(filename)
        root = tree.getroot()

        # Find all flaw elements and extract their parent elements
        for flaw in root.findall(".//flaw"):
            parent = flaw.getparent() if hasattr(flaw, 'getparent') else flaw.find("..")
            if parent is not None:
                path = parent.get('path')
                line = int(flaw.get('line', '0'))
                ground_truth.add((path, line))
    except ET.ParseError as e:
        logging.error(f"Error parsing XML file {filename}: {e}")
    except FileNotFoundError:
        logging.error(f"Manifest file not found: {filename}")
    except Exception as e:
        logging.error(f"Unexpected error while parsing manifest: {e}")
    return ground_truth


def parse_codeql_sarif(filename):
    """
    Parses the CodeQL SARIF file to extract findings for a specific rule.

    Args:
        filename (str): Path to the SARIF file.
        target_rule_id (str): The rule ID to filter results (default: "cpp/uninitialized-local").

    Returns:
        list: A list of tuples containing (uri, line_number).
    """
    codeql_results = []
    try:
        with open(filename, 'r') as f:
            sarif_data = json.load(f)

        for run in sarif_data.get('runs', []):
            rules_metadata = run.get('tool', {}).get('driver', {}).get('rules', [])
            for result in run.get('results', []):
                rule_id = result.get('ruleId')
                for location in result.get('locations', []):
                    phys_loc = location.get('physicalLocation', {})
                    artifact = phys_loc.get('artifactLocation', {})
                    uri = artifact.get('uri')
                    lineno = phys_loc.get('region', {}).get('startLine')

                    if uri and lineno:
                        codeql_results.append((uri, lineno))
                    else:
                        logging.warning(f"Missing URI or line number in result: {result}")

    except FileNotFoundError:
        logging.error(f"SARIF file not found: {filename}")
    except json.JSONDecodeError as e:
        logging.error(f"Error parsing SARIF JSON file {filename}: {e}")
    except Exception as e:
        logging.error(f"Unexpected error while parsing SARIF: {e}")

    logging.info(f"Parsed {len(codeql_results)} CodeQL results'.")
    return codeql_results


def parse_tagfile(tagfile):
    """
    Parses the tags file to map filenames to their functions and corresponding line ranges.

    Args:
        tagfile (str): Path to the tags file.

    Returns:
        dict: A dictionary mapping filenames to lists of (function_name, start_line, end_line).
    """
    tags = {}
    try:
        with open(tagfile, 'r') as file:
            for line in file:
                line = line.strip()
                if not line or line.startswith('!'):
                    continue  # Skip empty lines and metadata

                parts = line.split('\t')
                if len(parts) < 3:
                    logging.warning(f"Malformed tags line: {line}")
                    continue

                funcname, filename, details = parts[:3]

                # Extract start and end lines using regex
                start_match = re.search(r'line:(\d+)', details)
                end_match = re.search(r'end:(\d+)', details)

                if start_match:
                    startline = int(start_match.group(1))
                else:
                    logging.warning(f"Start line not found in line: {line}")
                    startline = 0

                if end_match:
                    endline = int(end_match.group(1))
                else:
                    # If end line isn't provided, assume function is a single line
                    endline = startline

                tags.setdefault(filename, []).append((funcname, startline, endline))
    except FileNotFoundError:
        logging.error(f"Tags file not found: {tagfile}")
    except Exception as e:
        logging.error(f"Error parsing tags file {tagfile}: {e}")

    logging.info(f"Parsed tags for {len(tags)} files.")
    return tags


def is_good(string):
    """
    Checks if the given string indicates a 'good' (non-vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'good' is in the string, else False.
    """
    return bool(string) and re.search(r'\bgood\b', string, re.IGNORECASE)


def is_bad(string):
    """
    Checks if the given string indicates a 'bad' (vulnerable) entity.

    Args:
        string (str): The string to check.

    Returns:
        bool: True if 'bad' is in the string, else False.
    """
    return bool(string) and re.search(r'\bbad\b', string, re.IGNORECASE)


def categorize_findings(codeql_results, tags, ground_truth):
    """
    Categorizes CodeQL findings as True Positive (TP), False Positive (FP), or Unrelated.

    Args:
        codeql_results (list): List of tuples containing (uri, line_number).
        tags (dict): Parsed tags mapping filenames to functions.
        ground_truth (set): Set of tuples containing (file_path, line_number).

    Returns:
        tuple: Counts of (TP, FP, Unrelated).
    """
    cnt_tp = 0
    cnt_fp = 0
    cnt_unrelated = 0

    for uri, lineno in codeql_results:
        if is_good(uri):
            cnt_fp += 1
            continue
        if is_bad(uri):
            cnt_tp += 1
            continue

        functions = tags.get(uri, [])
        matched_funcs = [fname for fname, start, end in functions if start <= lineno <= end]

        if len(matched_funcs) == 1:
            func_name = matched_funcs[0]
            if is_good(func_name):
                cnt_fp += 1
            elif is_bad(func_name):
                cnt_tp += 1
            else:
                # If function name doesn't indicate 'good' or 'bad', check ground truth
                if (uri, lineno) in ground_truth:
                    cnt_tp += 1
                else:
                    cnt_unrelated += 1
        elif len(matched_funcs) > 1:
            logging.warning(f"Multiple functions matched for {uri}:{lineno}: {matched_funcs}")
            cnt_unrelated += 1
        else:
            logging.warning(f"No function matched for {uri}:{lineno}")
            cnt_unrelated += 1

    return cnt_tp, cnt_fp, cnt_unrelated


def main():
    args = parse_arguments()
    base_dir = os.path.dirname(os.path.abspath(args.sarif))

    # Parse the manifest XML to get ground truth data
    ground_truth = parse_manifest_xml(args.manifest)
    logging.info(f"Parsed ground truth with {len(ground_truth)} entries.")

    # Parse the tags file
    tags = parse_tagfile(args.tags)

    # Parse CodeQL SARIF results
    codeql_results = parse_codeql_sarif(args.sarif)

    # Categorize findings
    cnt_tp, cnt_fp, cnt_unrelated = categorize_findings(codeql_results, tags, ground_truth)

    # Output the results
    logging.info(f"True Positives (TP): {cnt_tp}")
    logging.info(f"False Positives (FP): {cnt_fp}")
    logging.info(f"Unrelated Findings: {cnt_unrelated}")

    # Print the counts
    print(cnt_tp, cnt_fp, cnt_unrelated)


if __name__ == '__main__':
    main()
