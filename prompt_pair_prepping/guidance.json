{
  "__comment": "Below are all codeql rules with high severity and medium precision. Created by jq '.runs[0].tool.driver.rules[] | select(.properties[\"security-severity\"] != null and (.properties[\"security-severity\"] | tonumber) >= 7.0 and .properties.precision == \"high\") | .id' cpp.sarif",

  "cpp/uncontrolled-allocation-size": "The warning is True positive if the memory allocation size has no bounds.",
  "cpp/certificate-not-checked": "",
  "cpp/certificate-result-conflation": "",
  "cpp/potentially-dangerous-function": "",
  "cpp/overrun-write": "The warning is False positive if the size of destination buffer is longer than source buffer.",
  "cpp/unsigned-difference-expression-compared-zero": "",
  "cpp/incorrect-allocation-error-handling": "When using new T or new(std::nothrow) T, programmer should use the corresponding method of error handling.",
  "cpp/world-writable-file-creation": "",
  "cpp/invalid-pointer-deref": "",
  "cpp/uncontrolled-process-operation": "",
  "cpp/cleartext-storage-database": "",
  "cpp/user-controlled-bypass": "",
  "cpp/use-after-free": "The warning is a false positive if the variable is not used after being freed along any execution path.",
  "cpp/double-free": "The warning is a false positive if the variable is not freed more than once without reallocation along any execution path.",
  "cpp/cleartext-storage-buffer": "",
  "cpp/unterminated-variadic-call": "",
  "cpp/overrunning-write-with-float": "The warning is False positive if the size of destination buffer is longer than source buffer.",
  "cpp/unbounded-write": "The warning is False positive if the size of destination buffer is longer than source buffer.",
  "cpp/overrunning-write": "The warning is False positive if the size of destination buffer is longer than source buffer.",
  "cpp/suspicious-pointer-scaling-void": "",
  "cpp/suspicious-pointer-scaling": "",
  "cpp/tainted-permissions-check": "",
  "cpp/path-injection": "",
  "cpp/unsafe-create-process-call": "",
  "cpp/allocation-too-small": "The warning is a false positive if the memory allocation size is sufficient for the data being stored, considering all execution paths.",
  "cpp/missing-check-scanf": "The return value of the sscanf call that writes into a variable is checked for the expected number of parsed items corresponding to the variable.",
  "cpp/suspicious-allocation-size": "The warning is False positive if the pointed-to type is a struct type with a flexible array member.",
  "cpp/offset-use-before-range-check": "The warning is False positive if the offset is within the bound of the array.",
  "cpp/comma-before-misleading-indentation": "",
  "cpp/incorrect-not-operator-usage": "",
  "cpp/uninitialized-local": "The warning at a specific source line is a false positive if the variable is always initialized along all the paths that reach that line.",
  "cpp/unsafe-strcat": "The maximum number of characters to append should be less than or equal to the remaining space in the destination buffer.",
  "cpp/suspicious-sizeof": "",
  "cpp/bad-strncpy-size": "The warning is False positive if the size of destination buffer is longer than source buffer.",
  "cpp/unsafe-strncat": "The maximum number of characters to append should be less than or equal to the remaining space in the destination buffer."
}
